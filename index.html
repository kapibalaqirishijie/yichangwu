<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>异常物对战v0.1</title>
  
  <!-- 仅保留必要依赖 -->
  <script src="https://cdn.jsdelivr.net/npm/leancloud-storage@4.15.1/dist/av-min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <link href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css" rel="stylesheet">
  
  <!-- LeanCloud 初始化 -->
  <script>
    const appId = "jbbgfC0tG7u5BNGPjAVrdBlJ-gzGzoHsz";
    const appKey = "zOYjnjqEOny7nUGpbAUy6UFQ";
    const serverURL = "https://jbbgfc0t.lc-cn-n1-shared.com";
    AV.init({ appId, appKey, serverURL });
  </script>
  
  <!-- Tailwind 配置（极简黑白+圆角） -->
  <script>
    tailwind.config = {
      theme: {
        extend: {
          colors: {
            primary: '#000000',
            secondary: '#333333',
            hover: '#e8e8e8',
          },
          fontFamily: {
            mono: ['"Courier New"', 'monospace'],
          },
        }
      }
    }
  </script>
  <style type="text/tailwindcss">
    @layer utilities {
      .border-simple { border: 1px solid #333; }
      .card-style { border: 1px solid #333; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
      .btn-style { border: 1px solid #333; border-radius: 6px; transition: all 0.2s ease; }
      .btn-style:hover { background: #e8e8e8; box-shadow: 0 2px 6px rgba(0,0,0,0.15); }
      .input-style { border: 1px solid #333; border-radius: 6px; transition: border 0.2s ease; }
      .input-style:focus { outline: none; border-color: #000; box-shadow: 0 0 0 2px rgba(0,0,0,0.05); }
    }
  </style>
  <style>
    body {
      background: #ffffff;
      color: #000000;
      font-family: 'Courier New', monospace;
    }
    .battle-log {
      overflow-y: auto;
      scrollbar-width: thin;
    }
    .battle-log::-webkit-scrollbar { width: 4px; }
    .battle-log::-webkit-scrollbar-thumb { background: #666; border-radius: 2px; }
    .turn-indicator {
      animation: blink 1.5s infinite;
    }
    @keyframes blink {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }
  </style>
</head>
<body class="min-h-screen">
  <!-- 登录弹窗 -->
  <div id="login-modal" class="fixed inset-0 bg-black/50 flex items-center justify-center z-50 hidden">
    <div class="bg-white card-style p-6 w-full max-w-md relative">
      <h3 class="text-xl font-bold text-center mb-6 border-b border-simple pb-2">玩家登录</h3>
      
      <!-- 切换登录/注册标签 -->
      <div class="flex border-b border-simple mb-4">
        <button id="login-tab" class="flex-1 py-2 border-b-2 border-primary">登录</button>
        <button id="register-tab" class="flex-1 py-2 text-gray-500">注册</button>
      </div>
      
      <!-- 登录表单 -->
      <div id="login-form">
        <div class="mb-3">
          <input type="text" id="login-username" placeholder="用户名" class="w-full input-style px-3 py-2">
        </div>
        <div class="mb-4">
          <input type="password" id="login-password" placeholder="密码（6位以上）" class="w-full input-style px-3 py-2">
        </div>
        <button id="do-login" class="w-full btn-style py-2">登录</button>
      </div>
      
      <!-- 注册表单（默认隐藏） -->
      <div id="register-form" class="hidden">
        <div class="mb-3">
          <input type="text" id="reg-username" placeholder="设置用户名" class="w-full input-style px-3 py-2">
        </div>
        <div class="mb-3">
          <input type="password" id="reg-password" placeholder="设置密码（6位以上）" class="w-full input-style px-3 py-2">
        </div>
        <div class="mb-4">
          <input type="password" id="reg-repassword" placeholder="确认密码" class="w-full input-style px-3 py-2">
        </div>
        <button id="do-register" class="w-full btn-style py-2">注册并登录</button>
      </div>
      
      <!-- 关闭按钮 -->
      <button id="close-login" class="absolute top-4 right-4 hover:text-gray-500 text-xl">×</button>
    </div>
  </div>

  <!-- 游戏容器 -->
  <div id="game-container" class="hidden container mx-auto px-4 py-8 max-w-4xl">
    <!-- 顶部导航 -->
    <header class="border-b border-simple mb-8 pb-4">
      <div class="flex flex-col md:flex-row justify-between items-start md:items-center gap-4">
        <h1 class="text-2xl font-bold">异常物对战v0.1</h1>
        <div class="flex items-center space-x-4">
          <span id="player-name" class="btn-style px-3 py-1">幸存者</span>
          <button id="show-login" class="btn-style px-3 py-1 hidden">登录</button>
          <button id="logout-btn" class="btn-style px-3 py-1 hidden">退出登录</button>
        </div>
      </div>
      
      <!-- 导航菜单 -->
      <nav class="flex space-x-6 mt-4">
        <button id="nav-home" class="border-b-2 border-primary py-1 text-sm md:text-base">首页</button>
        <button id="nav-collection" class="py-1 hover:bg-hover rounded px-2 text-sm md:text-base transition-colors">异常物图鉴</button>
        <button id="nav-profile" class="py-1 hover:bg-hover rounded px-2 text-sm md:text-base transition-colors">个人信息</button>
      </nav>
    </header>

    <!-- 主内容区 -->
    <main>
      <!-- 首页（仅保留匹配和红龙预览，移除统计卡片） -->
      <section id="home-page" class="space-y-8">
        <!-- 匹配对战入口 -->
        <div class="card-style p-6 text-center">
          <h2 class="text-xl font-bold mb-4">随机匹配对战</h2>
          <p class="mb-6 text-gray-600 text-sm md:text-base">点击下方按钮，匹配在线玩家进行回合制对战</p>
          <button id="start-match" class="btn-style px-6 py-3 text-lg">开始匹配</button>
          <div id="match-status" class="mt-4 text-gray-600 hidden">匹配中... 请等待其他玩家</div>
        </div>
        
        <!-- 红龙预览 -->
        <div class="card-style p-6">
          <h3 class="text-lg font-bold mb-4">当前可用异常物：红龙</h3>
          <div class="flex flex-col md:flex-row items-center">
            <img 
              src="https://raw.githubusercontent.com/kapibalaqirishijie/-/e5d289975b22651c56d0de0cbd6691d785b5bc17/%E6%B7%B7%E6%B2%8C%E7%BA%A2%E9%BE%99.jpg" 
              alt="红龙" 
              class="w-40 h-40 object-cover border-simple rounded-md mb-4 md:mb-0 md:mr-6"
            >
            <div class="text-left space-y-2 w-full md:w-auto">
              <p><span class="font-bold">属性：</span>火焰/龙</p>
              <p><span class="font-bold">攻击：</span>92</p>
              <p><span class="font-bold">防御：</span>78</p>
              <p><span class="font-bold">速度：</span>95</p>
              <p><span class="font-bold">技能：</span>烈焰突袭、火焰吞噬</p>
            </div>
          </div>
        </div>
      </section>

      <!-- 异常物图鉴 -->
      <section id="collection-page" class="hidden card-style p-6">
        <h2 class="text-xl font-bold mb-6">异常物图鉴</h2>
        <div id="collection-list" class="space-y-6">
          <!-- 动态加载 -->
        </div>
      </section>

      <!-- 个人信息 -->
      <section id="nav-profile-page" class="hidden card-style p-6">
        <h2 class="text-xl font-bold mb-6">个人对战数据</h2>
        <div id="profile-data" class="space-y-4">
          <!-- 动态加载 -->
        </div>
      </section>

      <!-- 对战页面（回合制） -->
      <section id="battle-page" class="hidden space-y-6">
        <h2 class="text-xl font-bold text-center">回合制对战</h2>
        
        <!-- 对战双方信息 -->
        <div class="flex justify-between mb-6 items-center">
          <div class="text-center flex flex-col items-center">
            <p class="font-bold" id="player1-name">你</p>
            <p id="player1-hp" class="mt-1">HP: 220/220</p>
            <span id="player1-turn" class="turn-indicator text-sm text-red-600 hidden mt-1">你的回合</span>
          </div>
          <div class="text-center">
            <p class="font-bold text-lg">VS</p>
          </div>
          <div class="text-center flex flex-col items-center">
            <p class="font-bold" id="player2-name">对手</p>
            <p id="player2-hp" class="mt-1">HP: 220/220</p>
            <span id="player2-turn" class="turn-indicator text-sm text-red-600 hidden mt-1">对手回合</span>
          </div>
        </div>
        
        <!-- 技能按钮 -->
        <div class="grid grid-cols-2 gap-4 mb-6" id="skill-container">
          <button id="skill1" class="btn-style p-4 pointer-events-none opacity-50">
            <p class="font-bold">烈焰突袭</p>
            <p class="text-sm text-gray-600">造成120%攻击伤害</p>
          </button>
          <button id="skill2" class="btn-style p-4 pointer-events-none opacity-50">
            <p class="font-bold">火焰吞噬</p>
            <p class="text-sm text-gray-600">造成150%攻击伤害，吸血30%</p>
          </button>
        </div>
        
        <!-- 战斗日志 -->
        <div class="card-style p-4 h-40 battle-log" id="battle-log">
          <p class="text-gray-600">战斗开始！随机分配先手...</p>
        </div>
        
        <!-- 战斗结果 -->
        <div id="battle-result" class="hidden text-center text-xl font-bold py-4">
          <p id="result-text"></p>
          <button id="return-home" class="btn-style px-4 py-2 mt-4">返回首页</button>
        </div>
      </section>
    </main>

    <!-- 页脚 -->
    <footer class="border-t border-simple mt-12 py-6 text-center text-gray-600 text-sm">
      <p>异常物对战v0.1 | 黑白极简回合制联机版</p>
    </footer>
  </div>

  <!-- 核心逻辑（彻底移除统计相关代码） -->
  <script>
    // 全局变量
    let currentUser = null;
    let matchInterval = null;
    let battleRoomId = null;
    let currentBattleRoom = null;
    let battleInterval = null;
    let isMyTurn = false;

    // DOM加载完成后初始化
    document.addEventListener('DOMContentLoaded', () => {
      initLoginRegister();    // 登录/注册
      initPageSwitch();       // 页面切换
      checkLoginState();      // 登录态检查
      initMatchFunction();    // 匹配功能
    });

    // 1. 登录/注册逻辑（无统计相关代码）
    function initLoginRegister() {
      // 切换登录/注册表单
      document.getElementById('login-tab').addEventListener('click', () => {
        document.getElementById('login-form').classList.remove('hidden');
        document.getElementById('register-form').classList.add('hidden');
        document.getElementById('login-tab').classList.add('border-b-2', 'border-primary');
        document.getElementById('login-tab').classList.remove('text-gray-500');
        document.getElementById('register-tab').classList.remove('border-b-2', 'border-primary');
        document.getElementById('register-tab').classList.add('text-gray-500');
      });

      document.getElementById('register-tab').addEventListener('click', () => {
        document.getElementById('register-form').classList.remove('hidden');
        document.getElementById('login-form').classList.add('hidden');
        document.getElementById('register-tab').classList.add('border-b-2', 'border-primary');
        document.getElementById('register-tab').classList.remove('text-gray-500');
        document.getElementById('login-tab').classList.remove('border-b-2', 'border-primary');
        document.getElementById('login-tab').classList.add('text-gray-500');
      });

      // 显示/隐藏登录弹窗
      document.getElementById('show-login').addEventListener('click', () => {
        document.getElementById('login-modal').classList.remove('hidden');
      });

      document.getElementById('close-login').addEventListener('click', () => {
        document.getElementById('login-modal').classList.add('hidden');
      });

      // 注册功能
      document.getElementById('do-register').addEventListener('click', async () => {
        const username = document.getElementById('reg-username').value.trim();
        const password = document.getElementById('reg-password').value;
        const repassword = document.getElementById('reg-repassword').value;

        // 基础验证
        if (!username || !password) {
          alert('用户名和密码不能为空！');
          return;
        }
        if (password !== repassword) {
          alert('两次密码不一致！');
          return;
        }
        if (password.length < 6) {
          alert('密码长度不能少于6位！');
          return;
        }

        try {
          // 创建LeanCloud用户
          const user = new AV.User();
          user.setUsername(username);
          user.setPassword(password);
          await user.signUp();
          currentUser = user;

          // 初始化对战数据
          const PlayerStats = AV.Object.extend('PlayerStats');
          const stats = new PlayerStats();
          stats.set('user', user);
          stats.set('winCount', 0);
          stats.set('loseCount', 0);
          stats.set('winRate', 0);
          await stats.save();

          // 初始化异常物数据
          const UserAbnormal = AV.Object.extend('UserAbnormal');
          const abnormal = new UserAbnormal();
          abnormal.set('user', user);
          abnormal.set('abnormalId', 1);
          abnormal.set('name', '红龙');
          abnormal.set('attack', 92);
          abnormal.set('defense', 78);
          abnormal.set('speed', 95);
          abnormal.set('skills', ['烈焰突袭', '火焰吞噬']);
          abnormal.set('imageUrl', 'https://raw.githubusercontent.com/kapibalaqirishijie/-/e5d289975b22651c56d0de0cbd6691d785b5bc17/%E6%B7%B7%E6%B2%8C%E7%BA%A2%E9%BE%99.jpg');
          await abnormal.save();

          alert('注册成功！已自动登录');
          document.getElementById('login-modal').classList.add('hidden');
          // 自动显示游戏容器（无需刷新）
          document.getElementById('game-container').classList.remove('hidden');
          document.getElementById('show-login').classList.add('hidden');
          document.getElementById('logout-btn').classList.remove('hidden');
          updateUserInfo();
        } catch (error) {
          alert('注册失败：' + error.message);
        }
      });

      // 登录功能
      document.getElementById('do-login').addEventListener('click', async () => {
        const username = document.getElementById('login-username').value.trim();
        const password = document.getElementById('login-password').value;

        if (!username || !password) {
          alert('用户名和密码不能为空！');
          return;
        }

        try {
          currentUser = await AV.User.logIn(username, password);
          alert('登录成功！');
          document.getElementById('login-modal').classList.add('hidden');
          // 自动显示游戏容器（无需刷新）
          document.getElementById('game-container').classList.remove('hidden');
          document.getElementById('show-login').classList.add('hidden');
          document.getElementById('logout-btn').classList.remove('hidden');
          updateUserInfo();
        } catch (error) {
          alert('登录失败：' + error.message);
        }
      });

      // 退出登录
      document.getElementById('logout-btn').addEventListener('click', async function() {
        try {
          AV.User.logOut();
          localStorage.removeItem('currentUser');
          window.location.reload();
        } catch (error) {
          alert('退出失败：' + error.message);
        }
      });
    }

    // 2. 页面切换逻辑
    function initPageSwitch() {
      // 导航切换
      document.getElementById('nav-home').addEventListener('click', () => {
        showPage('home-page');
        updateNavActive('nav-home');
      });

      document.getElementById('nav-collection').addEventListener('click', () => {
        showPage('collection-page');
        updateNavActive('nav-collection');
        loadCollectionData();
      });

      document.getElementById('nav-profile').addEventListener('click', () => {
        showPage('nav-profile-page');
        updateNavActive('nav-profile');
        loadProfileData();
      });

      // 对战后返回首页
      document.getElementById('return-home').addEventListener('click', () => {
        showPage('home-page');
        updateNavActive('nav-home');
        if (battleInterval) clearInterval(battleInterval);
        battleRoomId = null;
        currentBattleRoom = null;
        isMyTurn = false;
      });

      // 显示指定页面
      function showPage(pageId) {
        document.querySelectorAll('main section').forEach(section => {
          section.classList.add('hidden');
        });
        const targetPage = document.getElementById(pageId);
        if (targetPage) targetPage.classList.remove('hidden');
      }

      // 更新导航高亮
      function updateNavActive(navId) {
        document.querySelectorAll('nav button').forEach(btn => {
          btn.classList.remove('border-b-2', 'border-primary');
        });
        const targetNav = document.getElementById(navId);
        if (targetNav) targetNav.classList.add('border-b-2', 'border-primary');
      }
    }

    // 3. 检查登录态
    async function checkLoginState() {
      currentUser = AV.User.current();
      if (currentUser) {
        // 已登录：显示游戏容器
        document.getElementById('game-container').classList.remove('hidden');
        document.getElementById('show-login').classList.add('hidden');
        document.getElementById('logout-btn').classList.remove('hidden');
        updateUserInfo();
      } else {
        // 未登录：显示登录弹窗
        document.getElementById('game-container').classList.add('hidden');
        document.getElementById('show-login').classList.remove('hidden');
        document.getElementById('logout-btn').classList.add('hidden');
        document.getElementById('login-modal').classList.remove('hidden');
      }
    }

    // 4. 更新用户信息
    async function updateUserInfo() {
      if (!currentUser) return;
      const playerNameEl = document.getElementById('player-name');
      if (playerNameEl) playerNameEl.textContent = currentUser.getUsername() || '幸存者';
    }

    // 5. 匹配功能（两人同时进入对战）
    function initMatchFunction() {
      document.getElementById('start-match').addEventListener('click', async () => {
        if (!currentUser) {
          alert('请先登录后再匹配！');
          document.getElementById('login-modal').classList.remove('hidden');
          return;
        }

        // 显示匹配状态
        document.getElementById('start-match').classList.add('hidden');
        document.getElementById('match-status').classList.remove('hidden');

        try {
          // 创建匹配记录
          const MatchPool = AV.Object.extend('MatchPool');
          const matchRecord = new MatchPool();
          matchRecord.set('userId', currentUser.id);
          matchRecord.set('username', currentUser.getUsername());
          await matchRecord.save();
          const myMatchRecordId = matchRecord.id;

          // 定时查询对手
          matchInterval = setInterval(async () => {
            // 查是否有其他玩家（自己作为玩家1）
            const opponentQuery = new AV.Query('MatchPool');
            opponentQuery.notEqualTo('userId', currentUser.id);
            const otherPlayers = await opponentQuery.find();

            if (otherPlayers.length > 0) {
              const opponent = otherPlayers[0];
              await createBattleRoom(opponent, matchRecord);
              return;
            }

            // 查自己是否被匹配（自己作为玩家2）
            const battleRoomQuery = new AV.Query('BattleRoom');
            battleRoomQuery.equalTo('player2Id', currentUser.id);
            battleRoomQuery.equalTo('status', 'battling');
            const battleRooms = await battleRoomQuery.find();

            if (battleRooms.length > 0) {
              currentBattleRoom = battleRooms[0];
              battleRoomId = currentBattleRoom.id;
              await matchRecord.destroy();
              clearInterval(matchInterval);
              // 进入对战页面
              document.getElementById('start-match').classList.remove('hidden');
              document.getElementById('match-status').classList.add('hidden');
              showPage('battle-page');
              updateNavActive('');
              await initBattleLogic(currentBattleRoom);
              return;
            }
          }, 2000);
        } catch (error) {
          alert('匹配失败：' + error.message);
          document.getElementById('start-match').classList.remove('hidden');
          document.getElementById('match-status').classList.add('hidden');
          if (matchInterval) clearInterval(matchInterval);
        }
      });
    }

    // 创建对战房间
    async function createBattleRoom(opponent, myMatchRecord) {
      try {
        const BattleRoom = AV.Object.extend('BattleRoom');
        const battleRoom = new BattleRoom();
        battleRoom.set('player1Id', currentUser.id);
        battleRoom.set('player1Name', currentUser.getUsername());
        battleRoom.set('player2Id', opponent.get('userId'));
        battleRoom.set('player2Name', opponent.get('username'));
        battleRoom.set('status', 'battling');
        battleRoom.set('player1Hp', 220);
        battleRoom.set('player2Hp', 220);
        // 随机先手
        const firstAttack = Math.floor(Math.random() * 2) + 1;
        battleRoom.set('firstAttack', firstAttack);
        battleRoom.set('currentTurn', firstAttack);
        await battleRoom.save();

        currentBattleRoom = battleRoom;
        battleRoomId = battleRoom.id;

        // 清除匹配记录
        await myMatchRecord.destroy();
        await opponent.destroy();
        clearInterval(matchInterval);

        // 进入对战页面
        document.getElementById('start-match').classList.remove('hidden');
        document.getElementById('match-status').classList.add('hidden');
        showPage('battle-page');
        updateNavActive('');
        await initBattleLogic(battleRoom);
      } catch (error) {
        alert('创建对战房间失败：' + error.message);
        document.getElementById('start-match').classList.remove('hidden');
        document.getElementById('match-status').classList.add('hidden');
        if (matchInterval) clearInterval(matchInterval);
      }
    }

    // 6. 回合制对战逻辑
    async function initBattleLogic(battleRoom) {
      if (!battleRoom) return;
      currentBattleRoom = battleRoom;

      // 更新对战信息
      const isPlayer1 = battleRoom.get('player1Id') === currentUser.id;
      const player1Name = battleRoom.get('player1Name') || '未知玩家';
      const player2Name = battleRoom.get('player2Name') || '未知玩家';
      const player1Hp = battleRoom.get('player1Hp') || 220;
      const player2Hp = battleRoom.get('player2Hp') || 220;
      const currentTurn = battleRoom.get('currentTurn') || 1;

      // 显示名称和HP
      document.getElementById('player1-name').textContent = isPlayer1 ? '你' : player1Name;
      document.getElementById('player2-name').textContent = isPlayer1 ? player2Name : '你';
      document.getElementById('player1-hp').textContent = `HP: ${player1Hp}/${220}`;
      document.getElementById('player2-hp').textContent = `HP: ${player2Hp}/${220}`;

      // 判断当前回合
      isMyTurn = (currentTurn === 1 && isPlayer1) || (currentTurn === 2 && !isPlayer1);
      updateTurnIndicator();
      updateSkillButtonState();

      // 战斗日志
      const firstAttackName = currentTurn === 1 ? player1Name : player2Name;
      addBattleLog(`${firstAttackName}获得先手！`);

      // 监听对战状态
      if (battleInterval) clearInterval(battleInterval);
      battleInterval = setInterval(async () => {
        const query = new AV.Query('BattleRoom');
        try {
          const latestRoom = await query.get(battleRoomId);
          if (!latestRoom) return;

          currentBattleRoom = latestRoom;
          const newStatus = latestRoom.get('status');
          const newPlayer1Hp = latestRoom.get('player1Hp') || 220;
          const newPlayer2Hp = latestRoom.get('player2Hp') || 220;
          const newCurrentTurn = latestRoom.get('currentTurn') || 1;

          // 更新HP
          if (newPlayer1Hp !== player1Hp) {
            document.getElementById('player1-hp').textContent = `HP: ${newPlayer1Hp}/${220}`;
          }
          if (newPlayer2Hp !== player2Hp) {
            document.getElementById('player2-hp').textContent = `HP: ${newPlayer2Hp}/${220}`;
          }

          // 更新回合
          if (newCurrentTurn !== currentTurn) {
            isMyTurn = (newCurrentTurn === 1 && isPlayer1) || (newCurrentTurn === 2 && !isPlayer1);
            updateTurnIndicator();
            updateSkillButtonState();
            addBattleLog(`回合切换：${isMyTurn ? '你的回合' : '对手回合'}`);
          }

          // 战斗结束
          if (newStatus === 'ended') {
            clearInterval(battleInterval);
            const winnerName = latestRoom.get('winnerName') || '未知玩家';
            const isWin = winnerName === currentUser.getUsername();
            addBattleLog(`战斗结束！${winnerName}获胜！`);
            // 显示结果
            document.getElementById('battle-result').classList.remove('hidden');
            document.getElementById('result-text').textContent = isWin ? '恭喜你获得胜利！' : '很遗憾，你失败了';
            // 更新个人数据
            await updatePlayerStats(isWin);
            // 禁用技能按钮
            document.querySelectorAll('#skill-container button').forEach(btn => {
              btn.classList.add('pointer-events-none', 'opacity-50');
            });
          }
        } catch (error) {
          console.log('监听对战状态失败：', error);
        }
      }, 1000);

      // 技能按钮事件
      document.getElementById('skill1').addEventListener('click', () => {
        if (!isMyTurn) return;
        useSkill(1);
      });

      document.getElementById('skill2').addEventListener('click', () => {
        if (!isMyTurn) return;
        useSkill(2);
      });
    }

    // 使用技能
    async function useSkill(skillType) {
      if (!currentUser || !currentBattleRoom) return;

      const isPlayer1 = currentBattleRoom.get('player1Id') === currentUser.id;
      const myHpKey = isPlayer1 ? 'player1Hp' : 'player2Hp';
      const enemyHpKey = isPlayer1 ? 'player2Hp' : 'player1Hp';
      const myName = currentUser.getUsername();
      const enemyName = isPlayer1 ? currentBattleRoom.get('player2Name') : currentBattleRoom.get('player1Name');
      const attack = 92;
      let damage = 0;

      // 计算伤害
      if (skillType === 1) {
        damage = Math.round(attack * 1.2);
        addBattleLog(`${myName}使用了【烈焰突袭】！`);
      } else if (skillType === 2) {
        damage = Math.round(attack * 1.5);
        const 吸血 = Math.round(damage * 0.3);
        addBattleLog(`${myName}使用了【火焰吞噬】！`);
        addBattleLog(`${myName}吸血${吸血}点HP！`);
        currentBattleRoom.set(myHpKey, Math.min(currentBattleRoom.get(myHpKey) + 吸血, 220));
      }

      // 更新对手HP
      const newEnemyHp = Math.max(currentBattleRoom.get(enemyHpKey) - damage, 0);
      currentBattleRoom.set(enemyHpKey, newEnemyHp);
      addBattleLog(`${enemyName}受到${damage}点伤害！`);

      // 判断战斗是否结束
      if (newEnemyHp <= 0) {
        currentBattleRoom.set('status', 'ended');
        currentBattleRoom.set('winnerName', myName);
        currentBattleRoom.set('currentTurn', isPlayer1 ? 2 : 1);
      } else {
        currentBattleRoom.set('currentTurn', isPlayer1 ? 2 : 1);
      }

      // 保存状态
      try {
        await currentBattleRoom.save();
        // 禁用技能按钮
        document.querySelectorAll('#skill-container button').forEach(btn => {
          btn.classList.add('pointer-events-none', 'opacity-50');
        });
        // 更新HP显示
        document.getElementById('player1-hp').textContent = `HP: ${currentBattleRoom.get('player1Hp')}/${220}`;
        document.getElementById('player2-hp').textContent = `HP: ${currentBattleRoom.get('player2Hp')}/${220}`;
      } catch (error) {
        alert('释放技能失败：' + error.message);
      }
    }

    // 更新回合指示器
    function updateTurnIndicator() {
      const player1TurnEl = document.getElementById('player1-turn');
      const player2TurnEl = document.getElementById('player2-turn');

      if (isMyTurn) {
        player1TurnEl.classList.remove('hidden');
        player2TurnEl.classList.add('hidden');
      } else {
        player1TurnEl.classList.add('hidden');
        player2TurnEl.classList.remove('hidden');
      }
    }

    // 更新技能按钮状态
    function updateSkillButtonState() {
      const skillButtons = document.querySelectorAll('#skill-container button');
      if (isMyTurn) {
        skillButtons.forEach(btn => {
          btn.classList.remove('pointer-events-none', 'opacity-50');
        });
      } else {
        skillButtons.forEach(btn => {
          btn.classList.add('pointer-events-none', 'opacity-50');
        });
      }
    }

    // 添加战斗日志
    function addBattleLog(content) {
      const battleLogEl = document.getElementById('battle-log');
      if (!battleLogEl) return;
      const logItem = document.createElement('p');
      logItem.textContent = `> ${new Date().toLocaleTimeString()}：${content}`;
      battleLogEl.appendChild(logItem);
      battleLogEl.scrollTop = battleLogEl.scrollHeight;
    }

    // 更新个人对战数据
    async function updatePlayerStats(isWin) {
      if (!currentUser) return;
      const query = new AV.Query('PlayerStats');
      query.equalTo('user', currentUser);
      const stats = await query.first();

      if (stats) {
        let winCount = stats.get('winCount') || 0;
        let loseCount = stats.get('loseCount') || 0;

        if (isWin) winCount++;
        else loseCount++;

        const totalCount = winCount + loseCount;
        const winRate = totalCount > 0 ? Math.round((winCount / totalCount) * 100) : 0;

        stats.set('winCount', winCount);
        stats.set('loseCount', loseCount);
        stats.set('winRate', winRate);
        await stats.save();
      }
    }

    // 加载异常物图鉴
    async function loadCollectionData() {
      if (!currentUser) return;
      const collectionListEl = document.getElementById('collection-list');
      if (!collectionListEl) return;

      try {
        const query = new AV.Query('UserAbnormal');
        query.equalTo('user', currentUser);
        const abnormals = await query.find();

        collectionListEl.innerHTML = '';
        if (abnormals.length === 0) {
          collectionListEl.innerHTML = '<p class="text-center">暂无异常物数据</p>';
          return;
        }

        abnormals.forEach(abnormal => {
          const item = document.createElement('div');
          item.className = 'card-style p-4 flex flex-col md:flex-row items-center';
          item.innerHTML = `
            <img 
              src="${abnormal.get('imageUrl')}" 
              alt="${abnormal.get('name')}" 
              class="w-32 h-32 object-cover border-simple rounded-md mb-4 md:mb-0 md:mr-6"
            >
            <div class="space-y-2 w-full md:w-auto">
              <h4 class="text-lg font-bold">${abnormal.get('name')}</h4>
              <p><span class="font-bold">攻击：</span>${abnormal.get('attack')}</p>
              <p><span class="font-bold">防御：</span>${abnormal.get('defense')}</p>
              <p><span class="font-bold">速度：</span>${abnormal.get('speed')}</p>
              <p><span class="font-bold">技能：</span>${abnormal.get('skills').join('、')}</p>
            </div>
          `;
          collectionListEl.appendChild(item);
        });
      } catch (error) {
        collectionListEl.innerHTML = `<p class="text-center text-red-600">加载失败：${error.message}</p>`;
      }
    }

    // 加载个人信息
    async function loadProfileData() {
      if (!currentUser) return;
      const profileDataEl = document.getElementById('profile-data');
      if (!profileDataEl) return;

      try {
        const query = new AV.Query('PlayerStats');
        query.equalTo('user', currentUser);
        const stats = await query.first();

        if (stats) {
          const winCount = stats.get('winCount') || 0;
          const loseCount = stats.get('loseCount') || 0;
          const totalCount = winCount + loseCount;
          const winRate = totalCount > 0 ? Math.round((winCount / totalCount) * 100) : 0;

          profileDataEl.innerHTML = `
            <div class="card-style p-4">
              <p class="font-bold">用户名：${currentUser.getUsername() || '未知'}</p>
            </div>
            <div class="card-style p-4">
              <p>胜利场次：${winCount} 场</p>
            </div>
            <div class="card-style p-4">
              <p>失败场次：${loseCount} 场</p>
            </div>
            <div class="card-style p-4">
              <p>对战总场次：${totalCount} 场</p>
            </div>
            <div class="card-style p-4">
              <p>胜率：${winRate}%</p>
            </div>
          `;
        } else {
          profileDataEl.innerHTML = '<p class="text-center">暂无对战数据</p>';
        }
      } catch (error) {
        profileDataEl.innerHTML = `<p class="text-center text-red-600">加载失败：${error.message}</p>`;
      }
    }
  </script>
</body>
</html>
